//
// Created by 홍준근 on 2022/11/20.
//
#include <iostream>

int changeValue(int *p){
    *p = 3;

    return *p;
}

// 이렇게 사용하면 큰일난다.
// 이 함수 스택에 있는 레퍼런스를 반환해버리면 스택 메모리는 자동으로 사라지기 때문에 오류가 발생한다.
int& danglingFunction(){
    int a = 2;
    return a;
}

// 이렇게 사용해야 옳게된 레퍼런스 리턴 방법이다.
// 이런식으로 사용하는 이유는 보통 그냥 구조체를 리턴하면 call by copy가 일어나고 이때 비용이 상당히 많이 들기 때문이다.
// 특히 초당 수백~수천 요청처리를 해야하는 서버에서는 더욱 그러하다.
// 정리: 큰 구조체를 함수 파라미터로 넘길때 이 방법을 사용한다.
// 더군다나 실수로 다른 변수를 대입하는 경우를 방지해 런타임에 확실한 오류까지 잡아낼 수 있다.
int& refReturnFunction(int& a){
     a = 5;
     return a;
}

// 이 메서드를 레퍼런스로 받으면 컴파일 에러가 발생한다.
// 댕글링 레퍼런스가 되기 때문에 당연한 것이다.
// 다만, 이 메서드를 const 레퍼런스로 받으면 에러가 발생하지 않는다.
// 즉, const 레퍼런스는 예외적으로 댕글링 레퍼런스가 되더라도 생명이 연장되어 살아있게 된다.
int localReturnFunction(){
    int a = 5;
    return a;
}

// type& 으로 사용하는 레퍼런스 타입은 포인터와 달리 한번 대입하면 다른 변수로 참조가 불가능하며 반드시 선언 & 초기화로 선언 즉시 초기화해야한다.
// 단순한 별칭 사용에 가깝기 때문에 메모리에 존재하지 않을 수도 있다는 특이한 특징을 가지고 있다.
// 즉, 컴파일 과정에 이 별칭들이 전부 원래 변수로 바꿔치기가 된다는 뜻이다.
// 다만, 컴파일 과정을 거쳐도 메모리에 존재해야하는 경우가 존재한다.
// 그 경우는 const 레퍼런스에 함수로 값을 리턴 받아서 대입한 경우, 레퍼런스를 매개변수로 받는 함수에 레퍼런스를 넘긴 경우이다.
// 선자의 경우에는 함수의 지역 변수가 스택 메모리에서 사라지기 때문에 메모리에 존재하게 만들 필요가 있다. 이런 경우엔 레퍼런스를 메모리에 올리게 된다.
// 후자의 경우엔 레퍼런스를 매개변수로 받는 순간 이 스택 메모리에 이 래퍼런스를 올려야 넘겨받을 수 있게 된다. 이렇게 때문에 이 경우에도 레퍼런스를 메모리에 올리게 된다.
int main(){
    int number = 5;
    int& refNumber = number;

    std::cout<< number << std::endl;
    changeValue(&number);
    std::cout<< number << std::endl;

    std::cout<<"number: " << number << std::endl;
    std::cout<<"refNumber: " << refNumber << std::endl;
}